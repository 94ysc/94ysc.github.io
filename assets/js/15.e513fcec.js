(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{338:function(a,t,v){"use strict";v.r(t);var _=v(3),s=Object(_.a)({},(function(){var a=this,t=a.$createElement,v=a._self._c||t;return v("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[v("h1",{attrs:{id:"java特性"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#java特性"}},[a._v("#")]),a._v(" Java特性")]),a._v(" "),v("h2",{attrs:{id:"不可变量"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#不可变量"}},[a._v("#")]),a._v(" 不可变量")]),a._v(" "),v("ul",[v("li",[v("p",[a._v("不可变量指当一个对象被创建出来将不能被改变")])]),a._v(" "),v("li",[v("p",[a._v("不可变量将遵循五条基本原则")]),a._v(" "),v("ol",[v("li",[v("p",[a._v("类成员为private")])]),a._v(" "),v("li",[v("p",[a._v("没有修改成员变量的方式")])]),a._v(" "),v("li",[v("p",[a._v("所有方法不会被子类覆盖")])]),a._v(" "),v("li",[v("p",[a._v("成员初始化/获取成员时,使用clone方法保证类的不变性")])]),a._v(" "),v("li",[v("p",[a._v("覆盖equals().hashCode()方法")])])])])]),a._v(" "),v("h2",{attrs:{id:"equals-hashcode"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#equals-hashcode"}},[a._v("#")]),a._v(" ==,equals,hashCode")]),a._v(" "),v("ul",[v("li",[v("p",[a._v("== 用于判断两个基本数据类型和引用变量存储的内存地址是否相等")])]),a._v(" "),v("li",[v("p",[a._v("equals默认实现为==,用于判断两个对象是否相等,在自定义对象时,需要重写equals方法判断两个对象相等")])]),a._v(" "),v("li",[v("p",[a._v("hashCode默认实现是返回对象内存首地址的int值")])]),a._v(" "),v("li",[v("p",[a._v("重写equals的同时需要重写hashcode方法,否则在使用hash相关类时导致数据错误")])])]),a._v(" "),v("h2",{attrs:{id:"java本质是值传递"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#java本质是值传递"}},[a._v("#")]),a._v(" JAVA本质是值传递")]),a._v(" "),v("ul",[v("li",[a._v("对于基本数据类型是值传递,对于引用类型,传递的是对应的内存地址")])]),a._v(" "),v("h2",{attrs:{id:"java反射"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#java反射"}},[a._v("#")]),a._v(" JAVA反射")]),a._v(" "),v("ul",[v("li",[v("p",[a._v("获取类的访问修饰符,方法,属性及父类信息")])]),a._v(" "),v("li",[v("p",[a._v("在运行时根据类名字创建对象.运行时调用任意一个对象的方法")])]),a._v(" "),v("li",[v("p",[a._v("在运行时判断一个对象属于哪个类")])]),a._v(" "),v("li",[v("p",[a._v("生成动态代理")])])]),a._v(" "),v("h2",{attrs:{id:"泛型"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#泛型"}},[a._v("#")]),a._v(" 泛型")]),a._v(" "),v("ul",[v("li",[v("p",[a._v("泛型接口,泛型方法,泛型类")])]),a._v(" "),v("li",[v("p",[a._v("JAVA泛型必须基本数据类型是包装类")])]),a._v(" "),v("li",[v("p",[a._v("泛型擦除(擦除局部代码的泛型)")])])]),a._v(" "),v("h1",{attrs:{id:"容器类"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#容器类"}},[a._v("#")]),a._v(" 容器类")]),a._v(" "),v("h2",{attrs:{id:"collection"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#collection"}},[a._v("#")]),a._v(" collection")]),a._v(" "),v("ul",[v("li",[a._v("用于存储列表")])]),a._v(" "),v("h3",{attrs:{id:"list"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#list"}},[a._v("#")]),a._v(" List")]),a._v(" "),v("h4",{attrs:{id:"arraylist"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#arraylist"}},[a._v("#")]),a._v(" ArrayList")]),a._v(" "),v("ol",[v("li",[v("p",[a._v("随机访问")]),a._v(" "),v("p",[a._v("所有的数据块是连续的,每个数据库大小相同-> &i=&0+长度*i")])]),a._v(" "),v("li",[v("p",[a._v("读快写慢")])])]),a._v(" "),v("ul",[v("li",[v("p",[a._v("实现了RandomAccess(索引遍历比迭代器快)")])]),a._v(" "),v("li",[v("p",[a._v("实现了writeObject,readObject方法(由于列表提前初始化可能存在很多空对象,导致空间浪费,所以重写了序列化的方法)")])]),a._v(" "),v("li",[v("p",[a._v("默认初始化长度10,当新增数据达到11时,触发扩容将数组大小增加到原始大小的1.5倍")])])]),a._v(" "),v("h4",{attrs:{id:"linkedlist"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#linkedlist"}},[a._v("#")]),a._v(" linkedList")]),a._v(" "),v("ol",[v("li",[v("p",[a._v("顺序访问(双向链表)")])]),a._v(" "),v("li",[v("p",[a._v("写快读慢(读取只能遍历所以慢)")])])]),a._v(" "),v("h4",{attrs:{id:"vector-淘汰"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#vector-淘汰"}},[a._v("#")]),a._v(" Vector(淘汰)")]),a._v(" "),v("ul",[v("li",[a._v("与ArrayList一致,增加了线程安全的策略")])]),a._v(" "),v("h4",{attrs:{id:"stack是vector子类-淘汰"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#stack是vector子类-淘汰"}},[a._v("#")]),a._v(" Stack是Vector子类(淘汰)")]),a._v(" "),v("ul",[v("li",[a._v("实现了栈的方法")])]),a._v(" "),v("h4",{attrs:{id:"synchronizedlist替代"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#synchronizedlist替代"}},[a._v("#")]),a._v(" synchronizedList替代")]),a._v(" "),v("h3",{attrs:{id:"queue"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#queue"}},[a._v("#")]),a._v(" Queue")]),a._v(" "),v("ul",[v("li",[v("p",[a._v("使用线性表实现")])]),a._v(" "),v("li",[v("p",[a._v("先进先出")])])]),a._v(" "),v("h4",{attrs:{id:"priorityqueue"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#priorityqueue"}},[a._v("#")]),a._v(" PriorityQueue")]),a._v(" "),v("ul",[v("li",[a._v("需要提供比较器")]),a._v(" "),v("li",[a._v("使用最小堆实现")]),a._v(" "),v("li",[a._v("每次取出堆顶元素,再调整最小堆")]),a._v(" "),v("li",[a._v("把二叉树调整为最小堆\n"),v("ol",[v("li",[a._v("倒叙遍历")]),a._v(" "),v("li",[a._v("将二叉树的元素进行沉降")]),a._v(" "),v("li",[a._v("沉降后的节点继续沉降,直到叶子节点")])])])]),a._v(" "),v("h2",{attrs:{id:"map"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#map"}},[a._v("#")]),a._v(" map")]),a._v(" "),v("ul",[v("li",[a._v("存储键值对")]),a._v(" "),v("li")]),a._v(" "),v("comment-comment")],1)}),[],!1,null,null,null);t.default=s.exports}}]);